plugins {
    id 'com.android.application'
}

android {
    ndkVersion "25.2.9519653"
    compileSdk 33

    defaultConfig {
        applicationId "eu.vcmi.vcmi"
        minSdk 19
        //noinspection EditedTargetSdkVersion
        targetSdk 33
		versionCode 1400
		versionName "1.4.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

	signingConfigs {
		releaseSigning
		dailySigning
		LoadSigningConfig("releaseSigning")
		LoadSigningConfig("dailySigning")
	}

    buildTypes {
		debug {
			debuggable true
			applicationIdSuffix '.debug'
			manifestPlaceholders = [
				applicationLabel: 'VCMI debug',
			]
			ndk {
				debugSymbolLevel 'full'
			}
		}
		release {
			minifyEnabled false
			zipAlignEnabled true
			signingConfig signingConfigs.releaseSigning
			proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
			manifestPlaceholders = [
				applicationLabel: '@string/app_name',
			]
			ndk {
				debugSymbolLevel 'full'
			}
		}
		daily {
			initWith release
			applicationIdSuffix '.daily'
			signingConfig signingConfigs.dailySigning
			manifestPlaceholders = [
				applicationLabel: 'VCMI daily',
			]
		}
    }
	
	applicationVariants.all { variant -> RenameOutput(project.archivesBaseName, variant) }
	
	tasks.withType(JavaCompile) {
		options.compilerArgs += ["-Xlint:deprecation"]
	}

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    namespace 'eu.vcmi.vcmi'
	
	buildFeatures {
		viewBinding true
		dataBinding true
	}
	packagingOptions {
		jniLibs {
			useLegacyPackaging true
		}
	}
}

def RenameOutput(final baseName, final variant) {
	final def buildTaskId = System.getenv("GITHUB_RUN_ID")

	ResolveGitInfo()

	def name = baseName + "-" + ext.gitInfoVcmi

	if (buildTaskId != null && !buildTaskId.isEmpty()) {
		name = buildTaskId + "-" + name
	}

	if (!variant.buildType.name != "release") {
		name += "-" + variant.buildType.name
	}

	variant.outputs.each { output ->
		def oldPath = output.outputFile.getAbsolutePath()
		output.outputFileName = name + oldPath.substring(oldPath.lastIndexOf("."))
	}
}

def CommandOutput(final cmd, final arguments, final cwd) {
	try {
		new ByteArrayOutputStream().withStream { final os ->
			exec {
				executable cmd
				args arguments
				workingDir cwd
				standardOutput os
			}
			return os.toString().trim()
		}
	}
	catch (final Exception ex) {
		print("Broken: " + cmd + " " + arguments + " in " + cwd + " :: " + ex.toString())
		return ""
	}
}

def ResolveGitInfo() {
	if (ext.gitInfoVcmi != "none") {
		return
	}
	ext.gitInfoVcmi =
		CommandOutput("git", ["log", "-1", "--pretty=%D", "--decorate-refs=refs/remotes/origin/*"], ".").replace("origin/", "").replace(", HEAD", "").replaceAll("[^a-zA-Z0-9\\-_]", "_") +
		"-" +
		CommandOutput("git", ["describe", "--match=", "--always", "--abbrev=7"], ".")
}

def SigningPropertiesPath(final basePath, final signingConfigKey) {
	return file("${basePath}/${signingConfigKey}.properties")
}

def SigningKeystorePath(final basePath, final keystoreFileName) {
	return file("${basePath}/${keystoreFileName}")
}

def LoadSigningConfig(final signingConfigKey) {
	final def projectRoot = "${project.projectDir}/../../../CI/android"
	final def props = new Properties()
	final def propFile = SigningPropertiesPath(projectRoot, signingConfigKey)
	
	def signingConfig = android.signingConfigs.getAt(signingConfigKey)
	
	if (propFile.canRead()) {
		props.load(new FileInputStream(propFile))

		if (props != null
			&& props.containsKey('STORE_FILE')
			&& props.containsKey('KEY_ALIAS')) {

			signingConfig.storeFile = SigningKeystorePath(projectRoot, props['STORE_FILE'])
			signingConfig.storePassword = props['STORE_PASSWORD']
			signingConfig.keyAlias = props['KEY_ALIAS']
			
			if(props.containsKey('STORE_PASSWORD'))
				signingConfig.storePassword = props['STORE_PASSWORD']
			else
				signingConfig.storePassword = System.getenv("ANDROID_STORE_PASSWORD")
			
			if(props.containsKey('KEY_PASSWORD'))
				signingConfig.keyPassword = props['KEY_PASSWORD']
			else
				signingConfig.keyPassword = System.getenv("ANDROID_KEY_PASSWORD")
		} else {
			println("Some props from signing file are missing")
			android.signingConfigs.putAt(signingConfigKey, null)
		}
	} else {
		println("file with signing properties is missing")
		android.signingConfigs.putAt(signingConfigKey, null)
	}
}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.4.1'
    implementation 'com.google.android.material:material:1.5.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'

    // To use the Android Frame Pacing library
    //implementation "androidx.games:games-frame-pacing:1.9.1"

    // To use the Android Performance Tuner
    //implementation "androidx.games:games-performance-tuner:1.5.0"

    // To use the Games Activity library
    implementation "androidx.games:games-activity:1.1.0"

    // To use the Games Controller Library
    //implementation "androidx.games:games-controller:1.1.0"

    // To use the Games Text Input Library
    //implementation "androidx.games:games-text-input:1.1.0"
	implementation 'com.google.android.gms:play-services-base:18.2.0'
	implementation 'com.google.android.gms:play-services-basement:18.1.0'
}
configurations.implementation {
	exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk8'
}
